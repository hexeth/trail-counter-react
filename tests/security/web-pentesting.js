#!/usr/bin/env node

/**
 * Web Pages Penetration Testing Script
 * 
 * This script tests the security of the Trail Counter web pages
 * by checking authentication requirements, CSRF protections,
 * XSS vulnerabilities, and more.
 */

import puppeteer from 'puppeteer';
import chalk from 'chalk';
import axios from 'axios';

// Configuration
const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:5173';
const TEST_TRAIL_ID = 'dccdd470-c5da-48c7-bde2-669a4bd1edc2'; // Replace with a valid trail ID for testing
const AUTH_EMAIL = process.env.TEST_AUTH_EMAIL || 'testuser@test.com';
const AUTH_PASSWORD = process.env.TEST_AUTH_PASSWORD || 'testuser';

// Test results tracker
const results = {
  passed: 0,
  failed: 0,
  skipped: 0,
  tests: [],
};

// Utility functions
async function logTest(testName, testFn) {
  try {
    console.log(chalk.blue(`\n🔍 Running: ${testName}`));
    await testFn();
    console.log(chalk.green(`✅ PASSED: ${testName}`));
    results.passed++;
    results.tests.push({ name: testName, status: 'passed' });
    return true;
  } catch (error) {
    console.log(chalk.red(`❌ FAILED: ${testName}`));
    console.log(chalk.red(`   Error: ${error.message}`));
    results.failed++;
    results.tests.push({ name: testName, status: 'failed', error: error.message });
    return false;
  }
}

// Test public page accessibility
async function testPublicPages() {
  console.log(chalk.yellow('\n🌐 Testing Public Pages Accessibility'));
  
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });
  
  try {
    const page = await browser.newPage();
    
    // Set viewport for better screenshots
    await page.setViewport({ width: 1280, height: 800 });
    
    // Test home page accessibility
    await logTest('Home Page Accessibility', async () => {
      await page.goto(`${BASE_URL}/`, { waitUntil: 'networkidle0' });
      
      // Check if the page loaded successfully
      const title = await page.title();
      if (!title || title.includes('Error')) {
        throw new Error(`Home page failed to load properly: ${title}`);
      }
    });
    
    // Test registration page accessibility
    await logTest('Registration Page Accessibility', async () => {
      await page.goto(`${BASE_URL}/register/${TEST_TRAIL_ID}`, { waitUntil: 'networkidle0' });
      
      // Check if the page loaded successfully
      const title = await page.title();
      if (!title || title.includes('Error')) {
        throw new Error(`Registration page failed to load properly: ${title}`);
      }
      
      // Check for the registration form
      const formExists = await page.evaluate(() => {
        return document.querySelector('form') !== null;
      });
      
      if (!formExists) {
        throw new Error('Registration form not found on the page');
      }
    });
    
    // Test sign-in page accessibility
    await logTest('Sign-in Page Accessibility', async () => {
      await page.goto(`${BASE_URL}/sign-in`, { waitUntil: 'networkidle0' });
      
      // Check if the page loaded successfully
      const title = await page.title();
      if (!title || title.includes('Error')) {
        throw new Error(`Sign-in page failed to load properly: ${title}`);
      }
    });
  } finally {
    await browser.close();
  }
}

// Test authentication and authorization for admin pages
async function testAdminPageProtection() {
  console.log(chalk.yellow('\n🔒 Testing Admin Page Protection'));
  
  // Test direct HTTP access to admin pages (without browser)
  await logTest('Admin Page Protection', async () => {
    // Make a direct HTTP request to admin page with security test header
    const response = await axios.get(`${BASE_URL}/admin`, {
      headers: {
        'X-Security-Test': 'true' // Add security test header
      },
      validateStatus: null, // Don't throw on error status codes
      maxRedirects: 0 // Don't follow redirects
    });
    
    // Should be either a redirect (302) or unauthorized (401)
    if (response.status !== 302 && response.status !== 401) {
      throw new Error(`Admin page returned ${response.status} instead of 302 (redirect) or 401`);
    }
    
    // If it's a redirect, make sure it's to the sign-in page
    if (response.status === 302) {
      const location = response.headers.location;
      if (!location || !location.includes('/sign-in')) {
        throw new Error(`Admin page redirected to ${location} instead of sign-in page`);
      }
    }
  });
  
  // Test all admin routes also have protection - using direct HTTP access
  const adminRoutes = [
    '/admin/trails',
    '/admin/trails/new',
    '/admin/trails/' + TEST_TRAIL_ID + '/edit',
    '/admin/trails/' + TEST_TRAIL_ID + '/qr',
    '/admin/statistics',
    '/admin/templates',
    '/admin/data',
    '/admin/get-token',
    '/admin/logout',
  ];
  
  for (const route of adminRoutes) {
    await logTest(`Admin Route Protection: ${route}`, async () => {
      // Make a direct HTTP request to admin route with security test header
      const response = await axios.get(`${BASE_URL}${route}`, {
        headers: {
          'X-Security-Test': 'true' // Add security test header
        },
        validateStatus: null, // Don't throw on error status codes
        maxRedirects: 0 // Don't follow redirects
      });
      
      // Should be either a redirect (302) or unauthorized (401)
      if (response.status !== 302 && response.status !== 401) {
        throw new Error(`Admin route returned ${response.status} instead of 302 (redirect) or 401`);
      }
      
      // If it's a redirect, make sure it's to the sign-in page
      if (response.status === 302) {
        const location = response.headers.location;
        if (!location || !location.includes('/sign-in')) {
          throw new Error(`Admin route redirected to ${location} instead of sign-in page`);
        }
      }
    });
  }
  
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });
  
  try {
    const page = await browser.newPage();
    
    // Set viewport for better screenshots
    await page.setViewport({ width: 1280, height: 800 });
    
    // Set extra headers for all requests
    await page.setExtraHTTPHeaders({
      'X-Security-Test': 'true'
    });
    
    // Test that admin routes redirect to login when not authenticated (using browser)
    await logTest('Admin Homepage Redirect (Browser)', async () => {
      await page.goto(`${BASE_URL}/admin`, { waitUntil: 'networkidle0' });
      
      // Should redirect to login page
      const url = page.url();
      if (!url.includes('/sign-in') && !url.includes('/auth/sign-in') && !url.includes('/login')) {
        throw new Error(`Admin page did not redirect to login: ${url}`);
      }
    });
    
    // Additional browser tests can be performed here if needed
    
  } finally {
    await browser.close();
  }
}

// Test public pages for XSS vulnerabilities
async function testXSSVulnerabilities() {
  console.log(chalk.yellow('\n🔍 Testing for XSS Vulnerabilities'));
  
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });
  
  try {
    const page = await browser.newPage();
    
    // Set viewport
    await page.setViewport({ width: 1280, height: 800 });
    
    // Create an XSS payload test function
    const testXSSPayload = async (routeFunction) => {
      // Track if an alert was triggered
      let alertTriggered = false;
      
      // Set up dialog handler
      page.on('dialog', async (dialog) => {
        alertTriggered = true;
        await dialog.dismiss();
      });
      
      await routeFunction();
      
      // Wait a moment to see if any alerts are triggered using standard setTimeout
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      return !alertTriggered;
    };
    
    // Test registration page for XSS
    await logTest('Registration Page XSS Protection', async () => {
      // XSS payload in URL parameters
      const xssPayload = '<script>alert("XSS")</script>';
      const xssRoute = `/register/${TEST_TRAIL_ID}?name=${encodeURIComponent(xssPayload)}`;
      
      const isProtected = await testXSSPayload(async () => {
        await page.goto(`${BASE_URL}${xssRoute}`, { waitUntil: 'networkidle0' });
      });
      
      if (!isProtected) {
        throw new Error('XSS vulnerability detected in registration page');
      }
    });
    
    // Test home page for XSS
    await logTest('Home Page XSS Protection', async () => {
      // XSS payload in URL parameters
      const xssPayload = '<script>alert("XSS")</script>';
      const xssRoute = `/?search=${encodeURIComponent(xssPayload)}`;
      
      const isProtected = await testXSSPayload(async () => {
        await page.goto(`${BASE_URL}${xssRoute}`, { waitUntil: 'networkidle0' });
      });
      
      if (!isProtected) {
        throw new Error('XSS vulnerability detected in home page');
      }
    });
    
    // Test form input sanitization for XSS
    await logTest('Form Input XSS Protection', async () => {
      // Navigate to the registration page
      await page.goto(`${BASE_URL}/register/${TEST_TRAIL_ID}`, { waitUntil: 'networkidle0' });
      
      // Check if there's a form with a name field
      const hasNameField = await page.evaluate(() => {
        return document.querySelector('input[name="riderName"]') !== null;
      });
      
      if (hasNameField) {
        // Try to inject XSS payload into the name field
        const xssPayload = '<script>alert("XSS")</script>';
        await page.type('input[name="riderName"]', xssPayload);
        
        // Try to submit the form
        const isProtected = await testXSSPayload(async () => {
          const submitButton = await page.$('button[type="submit"]');
          if (submitButton) {
            await submitButton.click();
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        });
        
        if (!isProtected) {
          throw new Error('XSS vulnerability detected in form submission');
        }
      } else {
        console.log(chalk.yellow('⚠️ Warning: Could not find name field to test for XSS in form inputs'));
      }
    });
  } finally {
    await browser.close();
  }
}

// Test CSRF protections
async function testCSRFProtection() {
  console.log(chalk.yellow('\n🔍 Testing CSRF Protections'));
  
  // Test CSRF vulnerability on registration endpoint
  await logTest('Registration Endpoint CSRF Protection', async () => {
    // Try registering without proper origin headers
    const registrationData = {
      trailId: TEST_TRAIL_ID,
      riderName: 'CSRF Test',
      horseCount: 3,
      notes: 'Security test for CSRF'
    };
    
    try {
      const response = await axios.post(`${BASE_URL}/api/public/registrations`, registrationData, {
        headers: {
          'Origin': 'https://malicious-site.example.com',
          'Content-Type': 'application/json'
        },
        validateStatus: null
      });
      
      // If the server has CSRF protection for different origins, it would reject this
      // But our public endpoint should allow this since it's designed to be embedded on different domains
      // For public endpoints, we verify it works even with different origins
      if (response.status < 200 || response.status >= 300) {
        throw new Error(`Public registration endpoint should accept cross-origin requests but returned ${response.status}`);
      }
    } catch (error) {
      throw error;
    }
  });
  
  // Test CSRF protection on protected endpoints
  await logTest('Protected Endpoint CSRF Protection', async () => {
    try {
      const response = await axios.post(`${BASE_URL}/api/trails`, {
        name: 'CSRF Test Trail',
        location: 'CSRF Test Location'
      }, {
        headers: {
          'Origin': 'https://malicious-site.example.com',
          'Content-Type': 'application/json'
        },
        validateStatus: null
      });
      
      // Should reject with 401 Unauthorized, not 403 Forbidden (which would indicate CSRF check triggered)
      if (response.status !== 401) {
        throw new Error(`Protected endpoint without auth returned ${response.status} instead of 401`);
      }
    } catch (error) {
      if (error.response && error.response.status !== 401) {
        throw new Error(`Protected endpoint without auth returned ${error.response.status} instead of 401`);
      }
      throw error;
    }
  });
  
  // Test CSRF protection on authenticated requests
  await logTest('CSRF Protection on Authenticated Requests', async () => {
    if (!process.env.TEST_AUTH_TOKEN) {
      console.log(chalk.yellow('⚠️ Warning: Skipping authenticated CSRF test - no token provided'));
      results.skipped++;
      return;
    }
    
    try {
      const response = await axios.post(`${BASE_URL}/api/trails`, {
        name: 'CSRF Test Trail',
        location: 'CSRF Test Location'
      }, {
        headers: {
          'Origin': 'https://malicious-site.example.com',
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${process.env.TEST_AUTH_TOKEN}`
        },
        validateStatus: null
      });
      
      // Should reject cross-origin authenticated requests if CSRF protection is correctly implemented
      if (response.status < 400) {
        console.log(chalk.yellow('⚠️ Warning: Cross-origin request with valid token was accepted. Consider implementing CSRF protection for authenticated requests.'));
      }
    } catch (error) {
      // If we get an error, that might be good (CSRF protection working)
      if (error.response && error.response.status >= 400) {
        // This is the expected behavior if CSRF protection is enabled
      } else {
        throw error;
      }
    }
  });
}

// Test content security policy
async function testContentSecurityPolicy() {
  console.log(chalk.yellow('\n🔍 Testing Content Security Policy'));
  
  await logTest('CSP Headers', async () => {
    const response = await axios.get(`${BASE_URL}/register/${TEST_TRAIL_ID}`, {
      validateStatus: null
    });
    
    const headers = response.headers;
    const cspHeader = headers['content-security-policy'] || 
                     headers['Content-Security-Policy'] ||
                     headers['content-security-policy'] ||
                     headers['X-Content-Security-Policy'];
    
    // Check if CSP headers are present - this is optional but recommended
    if (!cspHeader) {
      console.log(chalk.yellow('⚠️ Warning: No Content Security Policy headers found. Consider adding CSP headers for additional security.'));
      // Not failing the test as CSP is recommended but not critical for this app
    }
  });
}

// Test for clickjacking protection with X-Frame-Options
async function testClickjackingProtection() {
  console.log(chalk.yellow('\n🔍 Testing Clickjacking Protection'));
  
  await logTest('X-Frame-Options Headers', async () => {
    const response = await axios.get(`${BASE_URL}/`, {
      validateStatus: null
    });
    
    const headers = response.headers;
    const xFrameOptions = headers['x-frame-options'] || 
                         headers['X-Frame-Options'];
    
    // Check if X-Frame-Options headers are present - this is recommended for admin pages
    if (!xFrameOptions) {
      console.log(chalk.yellow('⚠️ Warning: No X-Frame-Options headers found. Consider adding X-Frame-Options: DENY or SAMEORIGIN.'));
      // Not failing the test as X-Frame-Options is recommended but might be intentionally omitted for embeddable components
    }
  });
}

// Test error pages
async function testErrorPages() {
  console.log(chalk.yellow('\n🔍 Testing Error Pages'));
  
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox'],
  });
  
  try {
    const page = await browser.newPage();
    
    // Set viewport for better screenshots
    await page.setViewport({ width: 1280, height: 800 });
    
    // Test 404 page
    await logTest('404 Error Page', async () => {
      await page.goto(`${BASE_URL}/non-existent-page-${Date.now()}`, { waitUntil: 'networkidle0' });
      
      // Check if the page loaded returns a proper 404
      const status = await page.evaluate(() => {
        return document.title.includes('404') || 
               document.body.textContent.includes('not found') ||
               document.body.textContent.includes('404');
      });
      
      if (!status) {
        throw new Error('404 page does not properly indicate a not-found error');
      }
    });
  } finally {
    await browser.close();
  }
}

// Run tests
async function runTests() {
  console.log(chalk.cyan('🔒 Trail Counter Web Security Penetration Test'));
  console.log(chalk.cyan('===================================================='));
  console.log(`🌐 Testing against: ${BASE_URL}`);
  
  const startTime = Date.now();
  
  try {
    await testPublicPages();
    await testAdminPageProtection();
    await testXSSVulnerabilities();
    await testCSRFProtection();
    await testContentSecurityPolicy();
    await testClickjackingProtection();
    await testErrorPages();
    
    // Print summary
    const endTime = Date.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);
    
    console.log(chalk.cyan('\n===================================================='));
    console.log(chalk.cyan(`🔍 Test Summary (${duration}s):`));
    console.log(chalk.green(`✅ Passed: ${results.passed}`));
    console.log(chalk.red(`❌ Failed: ${results.failed}`));
    console.log(chalk.yellow(`⚠️ Skipped: ${results.skipped}`));
    
    if (results.failed > 0) {
      console.log(chalk.red('\n⚠️ WEB SECURITY VULNERABILITIES DETECTED ⚠️'));
      process.exit(1);
    } else {
      console.log(chalk.green('\n✅ All web security tests passed! No vulnerabilities detected.'));
      process.exit(0);
    }
  } catch (error) {
    console.error(chalk.red(`\n❌ Testing error: ${error.message}`));
    process.exit(1);
  }
}

runTests();
#!/usr/bin/env node

/**
 * API and Page Penetration Testing Script
 * 
 * This script tests the security of the Trail Counter API and web pages
 * by testing both public and protected endpoints to ensure proper authentication 
 * is enforced and security measures are in place.
 */

import axios from 'axios';
import { execSync } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import chalk from 'chalk';

// Configuration
const BASE_URL = process.env.TEST_BASE_URL || 'http://localhost:5173';
const TEST_TRAIL_ID = 'dccdd470-c5da-48c7-bde2-669a4bd1edc2'; // Replace with a valid trail ID for your tests
const VALID_TOKEN = process.env.TEST_AUTH_TOKEN || ''; // Set this to a valid auth token for testing protected endpoints

// Test configuration
const SECURITY_TESTS = {
  verbose: true,
  stopOnFirstFail: false,
};

// Test results tracker
const results = {
  passed: 0,
  failed: 0,
  skipped: 0,
  tests: [],
};

// Utility functions
async function logTest(testName, testFn) {
  try {
    console.log(chalk.blue(`\nüîç Running: ${testName}`));
    await testFn();
    console.log(chalk.green(`‚úÖ PASSED: ${testName}`));
    results.passed++;
    results.tests.push({ name: testName, status: 'passed' });
    return true;
  } catch (error) {
    const errorMessage = error.response?.data?.error || error.message || 'Unknown error';
    console.log(chalk.red(`‚ùå FAILED: ${testName}`));
    console.log(chalk.red(`   Error: ${errorMessage}`));
    if (error.response) {
      console.log(chalk.red(`   Status: ${error.response.status}`));
    }
    results.failed++;
    results.tests.push({ name: testName, status: 'failed', error: errorMessage });

    if (SECURITY_TESTS.stopOnFirstFail) {
      throw new Error(`Test failed: ${testName}`);
    }
    return false;
  }
}

// Helper functions
async function publicEndpointTest(endpoint, method = 'get', data = null) {
  try {
    const requestConfig = {
      method,
      url: `${BASE_URL}${endpoint}`,
      validateStatus: null, // Don't throw on any status
    };

    if (data && (method.toLowerCase() === 'post' || method.toLowerCase() === 'put')) {
      requestConfig.data = data;
    }

    const response = await axios(requestConfig);
    
    // Public endpoints should return a success status (2xx)
    if (response.status < 200 || response.status >= 300) {
      throw new Error(`Public endpoint returned ${response.status}`);
    }
    
    return response;
  } catch (error) {
    throw error;
  }
}

async function protectedEndpointTest(endpoint, method = 'get', data = null, token = null) {
  try {
    const requestConfig = {
      method,
      url: `${BASE_URL}${endpoint}`,
      validateStatus: null, // Don't throw on any status
      headers: {},
    };

    // Add auth token if provided
    if (token) {
      requestConfig.headers.Authorization = `Bearer ${token}`;
    }

    if (data && (method.toLowerCase() === 'post' || method.toLowerCase() === 'put')) {
      requestConfig.data = data;
    }

    const response = await axios(requestConfig);
    
    // Without a token, protected endpoints should return 401 Unauthorized
    if (!token && response.status !== 401) {
      throw new Error(`Protected endpoint without token returned ${response.status} instead of 401`);
    }
    
    // With a valid token, protected endpoints should return success (2xx)
    if (token && (response.status < 200 || response.status >= 300)) {
      throw new Error(`Protected endpoint with token returned ${response.status}`);
    }
    
    return response;
  } catch (error) {
    throw error;
  }
}

// Test Suites
async function testPublicEndpoints() {
  console.log(chalk.yellow('\nüìä Testing Public Endpoints'));

  // Test public trail info endpoint
  await logTest('Public Trail Info', async () => {
    const response = await publicEndpointTest(`/api/public/trails/${TEST_TRAIL_ID}`);
    if (!response.data.id || !response.data.name) {
      throw new Error('Public trail info endpoint did not return expected data');
    }
  });

  // Test public registration endpoint
  await logTest('Public Registration Creation', async () => {
    const registrationData = {
      trailId: TEST_TRAIL_ID,
      riderName: 'Test Rider',
      horseCount: 2,
      notes: 'Security test registration'
    };
    
    const response = await publicEndpointTest('/api/public/registrations', 'post', registrationData);
    if (!response.data.id) {
      throw new Error('Public registration endpoint did not return expected data');
    }
  });

  // Test public trail horse count endpoint
  await logTest('Public Trail Horse Count', async () => {
    const response = await publicEndpointTest(`/api/public/trails/${TEST_TRAIL_ID}/horse-count`);
    if (typeof response.data.count !== 'number') {
      throw new Error('Public trail horse count endpoint did not return expected data');
    }
  });
}

async function testProtectedEndpoints() {
  console.log(chalk.yellow('\nüîí Testing Protected Endpoints'));
  
  if (!VALID_TOKEN) {
    console.log(chalk.yellow('‚ö†Ô∏è Warning: No valid token provided. Will only test that endpoints require authentication.'));
  }

  // ==================== Trail Endpoints ====================
  
  // Test trails list endpoint (should require auth)
  await logTest('Trails List - Unauthorized', async () => {
    await protectedEndpointTest('/api/trails');
  });

  if (VALID_TOKEN) {
    await logTest('Trails List - Authorized', async () => {
      const response = await protectedEndpointTest('/api/trails', 'get', null, VALID_TOKEN);
      if (!Array.isArray(response.data)) {
        throw new Error('Trails list endpoint did not return an array');
      }
    });
  }

  // Test trail detail endpoint (should require auth)
  await logTest('Trail Detail - Unauthorized', async () => {
    await protectedEndpointTest(`/api/trails/${TEST_TRAIL_ID}`);
  });

  if (VALID_TOKEN) {
    await logTest('Trail Detail - Authorized', async () => {
      const response = await protectedEndpointTest(`/api/trails/${TEST_TRAIL_ID}`, 'get', null, VALID_TOKEN);
      if (!response.data.id) {
        throw new Error('Trail detail endpoint did not return expected data');
      }
    });
  }

  // Test trail registrations endpoint (should require auth)
  await logTest('Trail Registrations - Unauthorized', async () => {
    await protectedEndpointTest(`/api/trails/${TEST_TRAIL_ID}/registrations`);
  });

  if (VALID_TOKEN) {
    await logTest('Trail Registrations - Authorized', async () => {
      const response = await protectedEndpointTest(`/api/trails/${TEST_TRAIL_ID}/registrations`, 'get', null, VALID_TOKEN);
      if (!Array.isArray(response.data)) {
        throw new Error('Trail registrations endpoint did not return an array');
      }
    });
  }

  // Test trail creation (POST) endpoint (should require auth)
  await logTest('Trail Creation - Unauthorized', async () => {
    const trailData = {
      name: 'Test Trail',
      location: 'Test Location',
      description: 'Test Description'
    };
    await protectedEndpointTest('/api/trails', 'post', trailData);
  });

  // Test trail update (PUT) endpoint (should require auth)
  await logTest('Trail Update - Unauthorized', async () => {
    const trailData = {
      name: 'Updated Trail Name',
      location: 'Updated Location'
    };
    await protectedEndpointTest(`/api/trails/${TEST_TRAIL_ID}`, 'put', trailData);
  });

  // Test trail deletion (DELETE) endpoint (should require auth)
  await logTest('Trail Deletion - Unauthorized', async () => {
    await protectedEndpointTest(`/api/trails/${TEST_TRAIL_ID}`, 'delete');
  });

  // ==================== Statistics Endpoints ====================
  
  // Test statistics endpoint (should require auth)
  await logTest('Statistics - Unauthorized', async () => {
    await protectedEndpointTest('/api/statistics');
  });

  if (VALID_TOKEN) {
    await logTest('Statistics - Authorized', async () => {
      const response = await protectedEndpointTest('/api/statistics', 'get', null, VALID_TOKEN);
      if (!response.data.totalTrails && !response.data.totalRegistrations) {
        throw new Error('Statistics endpoint did not return expected data');
      }
    });
  }

  // Test paginated registrations endpoint (should require auth)
  await logTest('Paginated Registrations - Unauthorized', async () => {
    await protectedEndpointTest('/api/statistics/registrations?page=1&limit=10');
  });

  if (VALID_TOKEN) {
    await logTest('Paginated Registrations - Authorized', async () => {
      const response = await protectedEndpointTest('/api/statistics/registrations?page=1&limit=10', 'get', null, VALID_TOKEN);
      if (!response.data.items || !response.data.pagination) {
        throw new Error('Paginated registrations endpoint did not return expected data');
      }
    });
  }

  // Test analytics data endpoint (should require auth)
  await logTest('Analytics Data - Unauthorized', async () => {
    await protectedEndpointTest('/api/statistics/analytics');
  });

  if (VALID_TOKEN) {
    await logTest('Analytics Data - Authorized', async () => {
      const response = await protectedEndpointTest('/api/statistics/analytics', 'get', null, VALID_TOKEN);
      if (!response.data) {
        throw new Error('Analytics endpoint did not return expected data');
      }
    });
  }

  // ==================== Template Endpoints ====================
  
  // Test templates list endpoint (should require auth)
  await logTest('Templates List - Unauthorized', async () => {
    await protectedEndpointTest('/api/templates');
  });

  if (VALID_TOKEN) {
    await logTest('Templates List - Authorized', async () => {
      const response = await protectedEndpointTest('/api/templates', 'get', null, VALID_TOKEN);
      if (!Array.isArray(response.data)) {
        throw new Error('Templates endpoint did not return an array');
      }
    });
  }

  // Test template creation (POST) endpoint (should require auth)
  await logTest('Template Creation - Unauthorized', async () => {
    const templateData = {
      name: 'Test Template',
      content: '<p>Test content</p>'
    };
    await protectedEndpointTest('/api/templates', 'post', templateData);
  });

  // Test template detail endpoint (should require auth)
  await logTest('Template Detail - Unauthorized', async () => {
    await protectedEndpointTest('/api/templates/1'); // Using ID 1 as an example
  });

  // Test template update (PUT) endpoint (should require auth)
  await logTest('Template Update - Unauthorized', async () => {
    const templateData = {
      name: 'Updated Template Name',
      content: '<p>Updated content</p>'
    };
    await protectedEndpointTest('/api/templates/1', 'put', templateData); // Using ID 1 as an example
  });

  // Test template deletion (DELETE) endpoint (should require auth)
  await logTest('Template Deletion - Unauthorized', async () => {
    await protectedEndpointTest('/api/templates/1', 'delete'); // Using ID 1 as an example
  });
}

async function testSecurityBypass() {
  console.log(chalk.yellow('\nüîì Testing Security Bypass Attempts'));
  
  // Test HTTP method override bypass
  await logTest('HTTP Method Override Bypass', async () => {
    try {
      const response = await axios({
        method: 'get',
        url: `${BASE_URL}/api/trails`,
        headers: {
          'X-HTTP-Method-Override': 'GET',
          'X-Method-Override': 'GET',
          'X-Original-Method': 'GET',
        },
        validateStatus: null,
      });
      
      if (response.status !== 401) {
        throw new Error(`Method override bypass returned ${response.status} instead of 401`);
      }
    } catch (error) {
      if (error.response && error.response.status !== 401) {
        throw new Error(`Method override bypass returned ${error.response.status} instead of 401`);
      }
      throw error;
    }
  });
  
  // Test authentication bypass using empty token
  await logTest('Empty Token Bypass', async () => {
    try {
      const response = await axios({
        method: 'get',
        url: `${BASE_URL}/api/trails`,
        headers: {
          'Authorization': 'Bearer ',
        },
        validateStatus: null,
      });
      
      if (response.status !== 401) {
        throw new Error(`Empty token bypass returned ${response.status} instead of 401`);
      }
    } catch (error) {
      if (error.response && error.response.status !== 401) {
        throw new Error(`Empty token bypass returned ${error.response.status} instead of 401`);
      }
      throw error;
    }
  });
  
  // Test SQL injection in trail ID parameter
  await logTest('SQL Injection Prevention', async () => {
    const sqlInjectionIds = [
      "' OR '1'='1",
      "'; DROP TABLE trails; --",
      "') OR 1=1--",
    ];
    
    for (const injectionId of sqlInjectionIds) {
      const response = await axios({
        method: 'get',
        url: `${BASE_URL}/api/public/trails/${encodeURIComponent(injectionId)}`,
        validateStatus: null,
      });
      
      // Should return 404 Not Found, not 500 Server Error which would indicate potential vulnerability
      if (response.status !== 404) {
        throw new Error(`SQL injection test with "${injectionId}" returned ${response.status} instead of 404`);
      }
    }
  });
  
  // Test path traversal prevention
  await logTest('Path Traversal Prevention', async () => {
    const traversalPaths = [
      '../../../etc/passwd',
      '..%2f..%2f..%2fetc%2fpasswd',
      '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
    ];
    
    for (const path of traversalPaths) {
      const response = await axios({
        method: 'get',
        url: `${BASE_URL}/api/public/trails/${encodeURIComponent(path)}`,
        validateStatus: null,
      });
      
      // Should return 404 Not Found, not expose sensitive files
      if (response.status !== 404) {
        throw new Error(`Path traversal test with "${path}" returned ${response.status} instead of 404`);
      }
    }
  });

  // Test JWT tampering prevention
  await logTest('JWT Tampering Prevention', async () => {
    if (!VALID_TOKEN) {
      console.log(chalk.yellow('   ‚ö†Ô∏è Skipping JWT tampering test: No valid token provided'));
      results.skipped++;
      return;
    }

    // Test with a tampered token (replacing the last character)
    const tamperedToken = VALID_TOKEN.slice(0, -1) + (VALID_TOKEN.slice(-1) === 'a' ? 'b' : 'a');
    
    try {
      const response = await axios({
        method: 'get',
        url: `${BASE_URL}/api/trails`,
        headers: {
          'Authorization': `Bearer ${tamperedToken}`,
        },
        validateStatus: null,
      });
      
      if (response.status !== 401) {
        throw new Error(`Tampered JWT returned ${response.status} instead of 401`);
      }
    } catch (error) {
      if (error.response && error.response.status !== 401) {
        throw new Error(`Tampered JWT returned ${error.response.status} instead of 401`);
      }
      throw error;
    }
  });

  // Test rate limiting by making multiple requests in rapid succession
  await logTest('Rate Limiting', async () => {
    const NUM_REQUESTS = 50; // Adjust based on your rate limits
    const requests = [];
    
    for (let i = 0; i < NUM_REQUESTS; i++) {
      requests.push(axios({
        method: 'get',
        url: `${BASE_URL}/api/public/trails/${TEST_TRAIL_ID}`,
        validateStatus: null,
      }));
    }
    
    const responses = await Promise.all(requests);
    
    // Check if any response is 429 Too Many Requests
    const hasRateLimit = responses.some(response => response.status === 429);
    
    if (!hasRateLimit) {
      console.log(chalk.yellow('   ‚ö†Ô∏è Warning: No rate limiting detected after multiple requests'));
    }
  });
}

// Test page routes security
async function testPageSecurity() {
  console.log(chalk.yellow('\nüåê Testing Page Security'));

  // Test admin page protection
  await logTest('Admin Page Protection', async () => {
    try {
      const response = await axios({
        method: 'get',
        url: `${BASE_URL}/admin`,
        validateStatus: null,
        maxRedirects: 0, // Don't follow redirects
      });
      
      // Should redirect to login or return 401
      if (response.status !== 302 && response.status !== 401) {
        throw new Error(`Admin page returned ${response.status} instead of 302 (redirect) or 401`);
      }
    } catch (error) {
      // Axios throws on 302 with maxRedirects=0, which is what we want
      if (error.response && error.response.status !== 302 && error.response.status !== 401) {
        throw new Error(`Admin page returned ${error.response.status} instead of 302 (redirect) or 401`);
      }
      if (!error.response) {
        throw error;
      }
    }
  });

  // Test other admin page routes
  const adminRoutes = [
    '/admin/trails',
    '/admin/trails/new',
    '/admin/templates',
    '/admin/data',
    '/admin/statistics',
    '/admin/get-token',
  ];

  for (const route of adminRoutes) {
    await logTest(`Admin Route Protection: ${route}`, async () => {
      try {
        const response = await axios({
          method: 'get',
          url: `${BASE_URL}${route}`,
          validateStatus: null,
          maxRedirects: 0,
        });
        
        // Should redirect to login or return 401
        if (response.status !== 302 && response.status !== 401) {
          throw new Error(`Admin route returned ${response.status} instead of 302 (redirect) or 401`);
        }
      } catch (error) {
        // Axios throws on 302 with maxRedirects=0, which is what we want
        if (error.response && error.response.status !== 302 && error.response.status !== 401) {
          throw new Error(`Admin route returned ${error.response.status} instead of 302 (redirect) or 401`);
        }
        if (!error.response) {
          throw error;
        }
      }
    });
  }
}

// Run tests
async function runTests() {
  console.log(chalk.cyan('üîí Trail Counter API Security Penetration Test'));
  console.log(chalk.cyan('===================================================='));
  console.log(`üåê Testing against: ${BASE_URL}`);
  
  const startTime = Date.now();
  
  try {
    await testPublicEndpoints();
    await testProtectedEndpoints();
    await testSecurityBypass();
    await testPageSecurity();
    
    // Print summary
    const endTime = Date.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);
    
    console.log(chalk.cyan('\n===================================================='));
    console.log(chalk.cyan(`üîç Test Summary (${duration}s):`));
    console.log(chalk.green(`‚úÖ Passed: ${results.passed}`));
    console.log(chalk.red(`‚ùå Failed: ${results.failed}`));
    console.log(chalk.yellow(`‚ö†Ô∏è Skipped: ${results.skipped}`));
    
    if (results.failed > 0) {
      console.log(chalk.red('\n‚ö†Ô∏è SECURITY VULNERABILITIES DETECTED ‚ö†Ô∏è'));
      process.exit(1);
    } else {
      console.log(chalk.green('\n‚úÖ All security tests passed! No vulnerabilities detected.'));
      process.exit(0);
    }
  } catch (error) {
    console.error(chalk.red(`\n‚ùå Testing error: ${error.message}`));
    process.exit(1);
  }
}

runTests();